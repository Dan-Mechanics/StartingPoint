// Questions for teacher:
// 1. Do you want me to include x64 folder in there with debug and release or not ? <-------------
// 2. General nit-pick questions about all the naming conventions of all of this 
//      because naming conventions are peak.
// 3. Where are the slides for the operands ( banking app ) and friend keyword ? <-------------

// Note to self: friend operators are useful for implementing
// operators for fields that are normally inaccessible. 
// Does this mean you can make operators for classes that you
// yourself did not make?

// todo:
// try to make stuff work with paginas --> alle weegave --> command line tool ( eerst moet je goede cmake prolly 3.5 instlleren )
// volgens alle shit doen
// ander idee: check de versies van de github zoals in mail
// volg video om bit memes te doen
// doe bitmask operations and but bullshit bit operatorss --> solve the puzzle in the slide
// what je nu hebt is meer dan goed genoeg maar ik wil MEEEEER !!! yaaarrr  --> dus je kan basically dit al inleveren

#include "CircleEditor.h"
#include "BlackScreen.h"

#include <iostream>

int globalInt;

struct myStruct {
    bool a, b, c; // this is smaller because a bool is not one bit. een hele word van data.
    double mD; // random: twee stukken informatie moet lezen om die ene dubble op te halen, word boundries er komen bij
    int* myIntP; // bools vijf bytes of drie.
    bool d;
    short myShort;
    int myInt;
};

// je kan 8 bools met 1 byte ofzo. makes sense.
#pragma pack(push, 0)
// een bool neemt een hele byte in beslag voor 1 bit aan info.
// single bool is ineffecient want 
// & is sneller als bitwise if statement als de bits completely op de zelfde plek zijn want het is sneller.
// dit is handig booleans gaan vervangen

// pState = 5
// pState & FALLING
// typedef long long uint_64_t --> en dan in andere environment anders schriven is handig networking W
// truth tables
// bitmask collision, een enkele bit met elkaar vergelekn net zolang hele bitmask.
// bitlemon bitwiae operations:the most undereapced feature low level program
// leuke huiswerk: shift left en shift right operator << 2 = keer 4, heel snelle rekensommen.
// naar rechts shift raak je informatie kwijt en naar links niet, unless data type ophoud, daar kun je hele efficente shit te maken.
// leuk detail
// bits leren lezen W  XOR = !=
// cool way to swap variables with bits in the slide with no temp var.


// check huiswerk en i int kun je 32 booleans vervangen, want alles is alle.s als je optimzailseer voor size is lezen langzER ER VISa versa
// bitwise operators reten snel. dus bitwise operators zijn de bom. memeory-optimzed, vs of je wilt meer fps right.
// het liefst allebei, framerate en memory, geheugen ophalen is traag ish.
struct BadEntity1 {
    unsigned int health;
    //bool active, can_move, visible;
    // bitewise operators.
    char somebools;

    double precise_x;
    double preicse_y;
};

#pragma pack(pop)

#pragma pack(push, 4)
// een bool neemt een hele byte in beslag voor 1 bit aan info.
struct BadEntity2 {
    bool active;
    double precise_x;
    bool visible;
    double preicse_y;
    int health;
    bool can_move;
};
#pragma pack(pop)
#pragma pack(push, 8)
// een bool neemt een hele byte in beslag voor 1 bit aan info.
struct BadEntity3 {
    bool active;
    double precise_x;
    bool visible;
    double preicse_y;
    int health;
    bool can_move;
};

#pragma pack(pop)

/// <summary>
/// https://www.geeksforgeeks.org/cpp/cpp-polymorphism/
/// </summary>
int main() {
    // This way you can "easily" swap the apps.
    App* appPtr;

    CircleEditor circleEditor{};
    BlackScreen blackScreen{};

    appPtr = &blackScreen;


    static int staticInt;
    int stackInt;
    int* myIntPtr = new int(42);

    // get the adress of stuff
    std::cout << &globalInt << std::endl;
    std::cout << &stackInt << std::endl;
    std::cout << &staticInt << std::endl;

    std::cout << myIntPtr << std::endl;
    std::cout << &(*myIntPtr) << std::endl;

    int number = 0x12345678;
    unsigned char* bytes = (unsigned char*)&number;
    for (int i = 0; i < 4; i++) {
        // we have big endian because the big numbers are first,
        // this is important because in networking you send the bytes over but how the bytes are
        // handles is dependant on the "Environment" --> dus daarom is die environment belangrijk om te weten
        // 
        // .
        // 
       
        // std: hex is permannet meme.
        //std::cout << std::hex << (int)bytes[i] << " ";
    }

    std::cout << std::endl << sizeof(BadEntity1) << std::endl;
    std::cout << sizeof(BadEntity2) << std::endl;
    std::cout << sizeof(BadEntity3) << std::endl;

   // std::cout << std::endl << sizeof(myStruct);
   // std::cout << std::endl << offsetof(myStruct, a);
   // std::cout << std::endl << offsetof(myStruct, b);
   // std::cout << std::endl << offsetof(myStruct, c);
   // std::cout << std::endl << offsetof(myStruct, a);
   // std::cout << std::endl << offsetof(myStruct, a);
    
    // je wilt liever niet dat je 8 
    // kleiner maken van de data, minder vaak data hoeven te lezen

    return appPtr->run();
}